================================================================================
Quad Mesh + Standard Lit Shader + Per-Frame Sprite Animation 实现方案
================================================================================

【核心原理】
不使用整个 Spritesheet 纹理贴图，而是逐帧切换单个 Sprite 纹理
使用标准 URP Lit Shader，让2D精灵自然融合进3D光影环境
例：每一帧都从 Lullaby_BottomR_0.png, Lullaby_BottomR_1.png ... 等单帧切换
着色方式：标准光照（无Toon效果），平滑光影渐变，自然融合

================================================================================
第一部分：Shader 设计
================================================================================

文件位置：Assets/Shaders/QuadSpritesheetLit.shader

功能要求：
  ✓ 标准 URP Lit 着色（平滑光影渐变）
  ✓ 接受单帧纹理（不需要UV偏移计算）
  ✓ 完整 URP Lit 光照支持
  ✓ 支持投影和阴影接收
  ✓ 支持 PBR 参数（Metallic, Smoothness）
  ✓ 自然融合进3D环境（无特殊效果）

着色器参数：
  _MainTex          : Texture2D      // 当前帧纹理（逐帧切换）
  _Color            : Color          // 着色颜色
  _Metallic         : Float = 0      // 金属度
  _Smoothness       : Float = 0.5    // 粗糙度

标准着色核心实现：
  1. 获取 Main Light 的光照方向和强度
  2. 计算 Lambert diffuse (n·l)：直接使用（无阈值）
  3. 添加高光（Blinn-Phong）
  4. 添加最小环境光（0.05）防止过暗
  5. 支持额外光源叠加
  6. 结果：平滑的光影渐变，自然融合

Pass 配置：
  □ ForwardLit Pass（主光照）
    - Tags: LightMode = UniversalForward
    - 标准 Lit 着色管道
    - 支持 _MAIN_LIGHT_SHADOWS
    - 支持 _ADDITIONAL_LIGHTS
  
  □ ShadowCaster Pass（投影）
    - Tags: LightMode = ShadowCaster
    - ColorMask 0
    - 支持透贴透明度测试

================================================================================
第二部分：场景配置
================================================================================

场景文件：Assets/Scenes/SampleScene.unity

GameObject 结构调整：
  Player_Lullaby
    ├─ Transform
    ├─ Animator (已有，保留)
    ├─ PlayerRen (已有，小调整)
    └─ RenderSquare (修改)
        ├─ MeshFilter
        │  └─ sharedMesh: Quad (标准4顶点quad)
        │
        ├─ MeshRenderer
        │  ├─ material: Mat_QuadSpritesheetLit_Player (新shader - 标准Lit)
        │  ├─ shadowCastingMode: On
        │  └─ receiveShadows: true
        │
        └─ SpriteFrame Animator Script (新脚本)
           └─ 驱动 Material._MainTex

配置要点：
  □ 删除 RenderSquare 上的 SpriteRenderer（如果有）
  □ 添加 MeshFilter 和 MeshRenderer
  □ MeshFilter 使用 Quad 网格（Unity 内置或自建）
  □ MeshRenderer 使用 Mat_QuadSpritesheetLit_Player 材质（标准Lit）
  □ 材质初始 _MainTex 设置为 Lullaby_BottomR_0

================================================================================
第三部分：动画驱动脚本
================================================================================

文件位置：Assets/Scripts/SpriteFrameAnimator.cs

原理：
  - Animation Clip 记录关键帧时间和 Sprite 索引
  - 脚本在 Update 中检查当前 Sprite 索引
  - 根据索引切换 Material._MainTex 纹理

实现步骤：
  1. 修改 Animation Clip
     □ 删除原有 Sprite 属性
     □ Add Property → RenderSquare → (新增自定义 int 属性 "_SpriteIndex")
     □ 关键帧记录索引值：0, 1, 2, ..., 10
  
  2. 创建 SpriteFrameAnimator.cs：
     ```csharp
     public class SpriteFrameAnimator : MonoBehaviour
     {
         // 从 Lullaby_BottomR 提取的单帧 Sprite 数组
         public Sprite[] spriteFrames; // 11 个元素
         
         private Material material;
         private int lastSpriteIndex = -1;
         
         void Start()
         {
             material = GetComponent<MeshRenderer>().material;
             // 自动加载所有 Sprite
             spriteFrames = Resources.LoadAll<Sprite>("Lullaby_BottomR");
         }
         
         void Update()
         {
             // 从 Animator 的 Sprite 索引读取
             int currentIndex = GetCurrentSpriteIndex();
             
             if (currentIndex != lastSpriteIndex)
             {
                 if (currentIndex >= 0 && currentIndex < spriteFrames.Length)
                 {
                     Sprite sprite = spriteFrames[currentIndex];
                     material.SetTexture("_MainTex", sprite.texture);
                     lastSpriteIndex = currentIndex;
                 }
             }
         }
         
         int GetCurrentSpriteIndex()
         {
             // 从 Animation 状态读取当前 Sprite 索引
             // 或从其他来源获取
         }
     }
     ```

优点：
  ✓ 逻辑清晰易维护
  ✓ 自动加载纹理
  ✓ 易于扩展
  ✗ 需要 Sprite 数组正确初始化



================================================================================
第四部分：Sprite 资源准备
================================================================================

当前状态：
  Assets/Arts/Lullaby_BottomR.png
  ├─ Lullaby_BottomR_0
  ├─ Lullaby_BottomR_1
  ├─ ... (共11个单帧 Sprite)
  └─ Lullaby_BottomR_10

验证步骤：
  □ 打开 Lullaby_BottomR.png (在 Assets/Arts/)
  □ 在 Inspector 查看 Sprite Mode: Multiple
  □ 确认有 11 个单帧 Sprite (0-10)
  □ 检查 Pixels Per Unit 是否正确（通常 256）

如果没有自动切割：
  □ 手动设置：
    - Sprite Mode: Multiple
    - Pixels Per Unit: 256
    - 点击 Sprite Editor，手动切割 1行x11列 网格
  □ Apply 保存

================================================================================
第五部分：Animation Clip 编辑指南
================================================================================

文件：Assets/Animations/PlayerIdle_BottomRight.anim

具体操作：
  1. 删除原有 Sprite 属性
     □ 右键 Sprite 属性 > Remove Property
  
  2. Add Property → RenderSquare > (自定义属性)
     需要在脚本中支持该属性
  
  3. 添加关键帧，值为 Sprite 索引 (0-10)
  
  4. 脚本读取这个索引值，自动切换纹理

================================================================================
第六部分：Animator Controller 配置
================================================================================

文件：Assets/Animations/Player_Lullaby.controller

配置内容：
  □ Default State: PlayerIdle_BottomRight
  □ 动画：PlayerIdle_BottomRight.anim (修改后)
  □ 参数（如果需要）：speed, direction, isWalking 等
  □ 过渡条件（可选）

确保：
  □ Player_Lullaby GameObject 的 Animator 组件
    → Controller 指向此文件
  □ Animator 的 Avatar 设置（如果需要）

================================================================================
第七部分：材质配置
================================================================================

Material 创建：
  □ 右键 Assets/Materials > Create > Material
  □ 命名：Mat_QuadSpritesheetLit_Player
  □ Shader：Custom/QuadSpritesheetLit (标准Lit)
  □ 参数设置：
    - _MainTex：Lullaby_BottomR_0 (初始帧)
    - _Color：(1, 1, 1, 1) 白色（让光照直接作用）
    - _Metallic：0
    - _Smoothness：0.5

分配到场景：
  □ RenderSquare > MeshRenderer > Material
    → 拖拽 Mat_QuadSpritesheetLit_Player

================================================================================
第八部分：PlayerRen.cs 调整
================================================================================

文件：Assets/Scripts/PlayerRen.cs

需要调整的地方：
  □ 确保指向正确的 RenderSquare GameObject
  □ 获取 MeshRenderer（而不是 SpriteRenderer）
  □ 如果需要处理翻转：
    - 原来：spriteRenderer.flipX = true
    - 现在：考虑使用 Scale 或骨骼翻转
  □ 如果需要处理相机朝向（Billboard）：
    - 保留相机朝向逻辑
    - 仍然有效（作用在 Quad 上）

修改示例：
  ```csharp
  renderSquare = player.transform.Find("RenderSquare").gameObject;
  meshRenderer = renderSquare.GetComponent<MeshRenderer>();
  // 移除 spriteRenderer 相关代码
  ```

================================================================================
第九部分：测试检查清单
================================================================================

编译和基础检查：
  □ Shader 编译无错误
  □ Material 创建成功
  □ Scene 可以打开，无丢失引用
  □ Player_Lullaby 可见（黑色或有纹理）

动画播放检查：
  □ 进入 Play 模式
  □ Animator 自动播放 PlayerIdle_BottomRight
  □ 观察 RenderSquare 上的贴图逐帧变化
  □ 动画循环播放（不停止）

视觉效果检查：
  □ 角色显示为光滑着色（自然光影渐变）
  □ 角色光照响应流畅自然（无离散跳跃）
  □ 动画帧之间无闪烁

光照交互检查：
  □ 打开 Directional Light
  □ 观察角色被光照影响
  □ 转动光的方向，角色明亮度改变
  □ 角色投射阴影在地面

额外光源测试：
  □ 创建 Point Light
  □ 移动到角色周围，观察着色变化
  □ 切换 Light Color，观察自然光照效果

边界情况：
  □ 调整 _Metallic 从 0 改为 0.5，观察高光强度
  □ 调整 _Smoothness 从 0.5 改为 0.1 或 0.9，观察高光锐度
  □ 修改 _Color，观察色调变化

================================================================================
第十部分：可能的问题和解决方案
================================================================================

问题 1：Quad 看不见
  原因：法向量方向错误或 Quad 背对相机
  解决：
    □ 检查 MeshFilter 的 Quad 法向量是否指向 +Z
    □ 如果使用自建 Quad，确保顶点顺序正确

问题 2：纹理切换不工作
  原因：Animation Clip 属性绑定错误
  解决：
    □ 检查 Add Property 路径是否正确
    □ 确保 RenderSquare 上有 MeshRenderer
    □ 尝试手动设置 material._MainTex 测试

问题 3：光照融合效果不自然（过硬或过暗）
  原因：材质参数设置不合适，或光照配置问题
  解决：
    □ 确保 _Color 是 (1,1,1,1) 白色，让光照直接作用
    □ 调整 _Smoothness（0.5 最自然，0.1 更粗糙，0.9 更镜面）
    □ 调整 _Metallic（0 为非金属，0.5 增强高光）
    □ 确保 Directional Light 已启用
    □ 检查 Ambient Light 是否过高（应为 0 或很小的值）

问题 4：动画帧不对齐
  原因：关键帧时间不准确
  解决：
    □ 从截图重新读取准确时间
    □ 在 Animation 窗口拖动调整帧位置

问题 5：性能问题
  原因：材质切换频率过高或其他原因
  解决：
    □ 确保 Animation Clip 的采样率正确
    □ 检查是否有多余的脚本在运行
    □ 尽量减少 Draw Call

================================================================================
第十一部分：实现顺序和时间预估
================================================================================

步骤顺序：
  1. 创建 Shader (QuadSpritesheetLit.shader - 标准Lit)    ~ 20 分钟
  2. 创建 Material 和 Quad 网格配置                      ~ 10 分钟
  3. 修改或创建 Animation Clip                          ~ 20 分钟
  4. 调整场景和脚本                                    ~ 15 分钟
  5. 测试和调试                                       ~ 30 分钟
  
  总计：约 1.5-2 小时

关键路径：
  Shader 创建 → Material 配置 → Animation 编辑 → 测试

并行可做：
  □ 同时准备 Sprite 资源
  □ 同时检查 Animation 时间表

================================================================================
第十二部分：参考资料和文档
================================================================================

需要查阅的 Unity 文档：
  □ URP Shader 编写：Packages/Universal RP/Shaders/
  □ Animation Clip 编辑：Window > Animation
  □ Material 系统：Assets/Materials/
  □ MeshRenderer：Component 列表

关键代码参考：
  □ URP Core.hlsl 函数
  □ Lighting.hlsl 光照计算
  □ step() 函数用于 Toon 着色

================================================================================
END OF IMPLEMENTATION PLAN - 标准Lit版本
================================================================================

方案特点：
  ✅ 逐帧切换单个Sprite纹理（Material._MainTex动画绑定）
  ✅ 标准URP Lit着色器（平滑光影渐变，无Toon效果）
  ✅ 自然融合进3D环境（匹配参考图片美术风格）
  ✅ 完整光照和阴影支持（实时响应光源变化）
  ✅ PBR参数支持（Metallic、Smoothness微调）
  ✅ 实现简单高效（标准管道，易调试）
